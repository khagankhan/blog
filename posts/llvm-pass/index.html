<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Be an LLVM contributor: Writing an optimization pattern for LLVM | Just In Time</title>
<meta name="keywords" content="llvm, optimization">
<meta name="description" content="LLVM&rsquo;s Optimizations Are Truly Impressive
LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (get_sum function), and 2) select one of the two characters based on a condition argument (get_char function):
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int get_sum(int a, int b) {
    vector&lt;int&gt; vec1; // Create the first vector vec1
    vector&lt;int&gt; vec2; // Create the second vector vec2
    vec1.push_back(a); // Push the first argument to vec1
    vec2.push_back(b); // Push the second argument to vec2
    return vec1[0] &#43; vec2[0]; // Return the sum of them
}
// Create a similar logic for string values
char get_char(char a, char b, bool cond) {
    string str1{a};
    string str2{b};
    return cond ? str1[0] : str2[0];
}
get_sum(int, int):
        lea     eax, [rdi &#43; rsi]
        ret

get_char(char, char, bool):
        mov     eax, edi
        test    edx, edx
        cmove   eax, esi
        ret
For the get_sum function, the compiler takes advantage of the lea instruction for the calculation, and for get_char, it uses cmove which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to optimize both of them away, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen&rsquo;s excellent post), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)">
<meta name="author" content="Khagan Khan Karimov">
<link rel="canonical" href="https://khagankhan.github.io/posts/llvm-pass/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://khagankhan.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://khagankhan.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://khagankhan.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://khagankhan.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://khagankhan.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://khagankhan.github.io/posts/llvm-pass/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://khagankhan.github.io/posts/llvm-pass/">
  <meta property="og:site_name" content="Just In Time">
  <meta property="og:title" content="Be an LLVM contributor: Writing an optimization pattern for LLVM">
  <meta property="og:description" content="LLVM’s Optimizations Are Truly Impressive LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (get_sum function), and 2) select one of the two characters based on a condition argument (get_char function):
#include &lt;vector&gt; #include &lt;string&gt; using namespace std; int get_sum(int a, int b) { vector&lt;int&gt; vec1; // Create the first vector vec1 vector&lt;int&gt; vec2; // Create the second vector vec2 vec1.push_back(a); // Push the first argument to vec1 vec2.push_back(b); // Push the second argument to vec2 return vec1[0] &#43; vec2[0]; // Return the sum of them } // Create a similar logic for string values char get_char(char a, char b, bool cond) { string str1{a}; string str2{b}; return cond ? str1[0] : str2[0]; } get_sum(int, int): lea eax, [rdi &#43; rsi] ret get_char(char, char, bool): mov eax, edi test edx, edx cmove eax, esi ret For the get_sum function, the compiler takes advantage of the lea instruction for the calculation, and for get_char, it uses cmove which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to optimize both of them away, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen’s excellent post), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-08T00:00:00+00:00">
    <meta property="article:tag" content="Llvm">
    <meta property="article:tag" content="Optimization">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Be an LLVM contributor: Writing an optimization pattern for LLVM">
<meta name="twitter:description" content="LLVM&rsquo;s Optimizations Are Truly Impressive
LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (get_sum function), and 2) select one of the two characters based on a condition argument (get_char function):
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int get_sum(int a, int b) {
    vector&lt;int&gt; vec1; // Create the first vector vec1
    vector&lt;int&gt; vec2; // Create the second vector vec2
    vec1.push_back(a); // Push the first argument to vec1
    vec2.push_back(b); // Push the second argument to vec2
    return vec1[0] &#43; vec2[0]; // Return the sum of them
}
// Create a similar logic for string values
char get_char(char a, char b, bool cond) {
    string str1{a};
    string str2{b};
    return cond ? str1[0] : str2[0];
}
get_sum(int, int):
        lea     eax, [rdi &#43; rsi]
        ret

get_char(char, char, bool):
        mov     eax, edi
        test    edx, edx
        cmove   eax, esi
        ret
For the get_sum function, the compiler takes advantage of the lea instruction for the calculation, and for get_char, it uses cmove which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to optimize both of them away, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen&rsquo;s excellent post), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://khagankhan.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Be an LLVM contributor: Writing an optimization pattern for LLVM",
      "item": "https://khagankhan.github.io/posts/llvm-pass/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Be an LLVM contributor: Writing an optimization pattern for LLVM",
  "name": "Be an LLVM contributor: Writing an optimization pattern for LLVM",
  "description": "LLVM\u0026rsquo;s Optimizations Are Truly Impressive LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (get_sum function), and 2) select one of the two characters based on a condition argument (get_char function):\n#include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int get_sum(int a, int b) { vector\u0026lt;int\u0026gt; vec1; // Create the first vector vec1 vector\u0026lt;int\u0026gt; vec2; // Create the second vector vec2 vec1.push_back(a); // Push the first argument to vec1 vec2.push_back(b); // Push the second argument to vec2 return vec1[0] + vec2[0]; // Return the sum of them } // Create a similar logic for string values char get_char(char a, char b, bool cond) { string str1{a}; string str2{b}; return cond ? str1[0] : str2[0]; } get_sum(int, int): lea eax, [rdi + rsi] ret get_char(char, char, bool): mov eax, edi test edx, edx cmove eax, esi ret For the get_sum function, the compiler takes advantage of the lea instruction for the calculation, and for get_char, it uses cmove which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to optimize both of them away, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen\u0026rsquo;s excellent post), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)\n",
  "keywords": [
    "llvm", "optimization"
  ],
  "articleBody": "LLVM’s Optimizations Are Truly Impressive LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (get_sum function), and 2) select one of the two characters based on a condition argument (get_char function):\n#include #include using namespace std; int get_sum(int a, int b) { vector\u003cint\u003e vec1; // Create the first vector vec1 vector\u003cint\u003e vec2; // Create the second vector vec2 vec1.push_back(a); // Push the first argument to vec1 vec2.push_back(b); // Push the second argument to vec2 return vec1[0] + vec2[0]; // Return the sum of them } // Create a similar logic for string values char get_char(char a, char b, bool cond) { string str1{a}; string str2{b}; return cond ? str1[0] : str2[0]; } get_sum(int, int): lea eax, [rdi + rsi] ret get_char(char, char, bool): mov eax, edi test edx, edx cmove eax, esi ret For the get_sum function, the compiler takes advantage of the lea instruction for the calculation, and for get_char, it uses cmove which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to optimize both of them away, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen’s excellent post), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)\nMissed optimizations Despite the many existing optimizations, there are still several optimization patterns missing. These optimizations either do not trigger frequently enough to be incorporated into the LLVM production pipeline, or they have been genuinely overlooked. During the testing of LLVM’s optimization techniques, I came across one such missing pattern, which I discussed in my previous post. The pattern in question is: X - Y + Y * 2 = X + Y. In this post, we will be adding this pattern to LLVM.\nWrite an optimization pattern First, we need to install LLVM. After cloning the repository, I typically use the following command:\ncmake .. -GNinja -DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_EH=ON -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_ENABLE_PROJECTS=\"llvm;clang\" /path/to/llvm -DBUILTINS_CMAKE_ARGS=-DCOMPILER_RT_ENABLE_IOS=OFF Next, we need to find the appropriate place to add the pattern. For this optimization, the ideal location appears to be llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp. Before proceeding, we want to ensure that our optimization fires as frequently as possible. To achieve this, we generalize the pattern X - Y + Y * 2 = X + Y to X - Y + Y * N = X + Y * (N - 1).\nLLVM provides APIs for implementing optimization patterns. These APIs are so well-developed that they can almost be considered a DSL for adding such patterns.\nSince adding a missing optimization was part of a course assignment (see the Acknowledgement section), I will use the same technique to add and test this optimization. To begin, we add the following:\n// I keep the name of the function used for the assignment Instruction* cs6475_optimizer(Instruction *I, InstCombinerImpl \u0026IC) { // Create a constant integer and placeholder values for variables and subexpressions. ConstantInt *C = nullptr; // Represents a compile-time constant integer value. Value *X = nullptr; // Represents a generic LLVM value (could be an instruction, constant, etc.). Value *Y = nullptr; // Another generic LLVM value. Value *LHS = nullptr; // Left-hand side of an addition operation. Value *RHS = nullptr; // Right-hand side of an addition operation. // Match a pattern to see if I is an addition of two values. if (match(I, m_c_Add(m_Value(LHS), m_Value(RHS)))) { // Check if the left-hand side (LHS) matches the pattern: X - Y. if (match(LHS, m_Sub(m_Value(X), m_Value(Y))) \u0026\u0026 // Check if the right-hand side (RHS) matches the pattern: Y * C (Y multiplied by a constant integer C). match(RHS, m_c_Mul(m_Value(Y), m_ConstantInt(C)))) { // Create a new multiplication instruction: Y * (C - 1). log_optzn(\"Khagan Karimov\"); // Log the frequency Value *NewMul = IC.Builder.CreateMul( Y, IC.Builder.CreateSub(C, ConstantInt::get(C-\u003egetType(), 1))); // Create a new addition instruction: X + (Y * (C - 1)). Instruction *NewAdd = BinaryOperator::CreateAdd(X, NewMul); // Return the newly created instruction. return NewAdd; } } } ConstantInt: Represents an immutable integer constant at compile-time.\nValue: Base class for all values in LLVM IR, including constants, instructions, and function arguments.\nmatch(): Matches an LLVM IR pattern against a value or instruction.\nm_c_Add: Matches a commutative addition operation. m_Sub: Matches a subtraction operation. m_c_Mul: Matches a commutative multiplication operation. m_Value: Matches any LLVM Value. m_ConstantInt: Matches an LLVM ConstantInt. IC.Builder.CreateMul(): Creates a multiplication instruction in the current IR context using the provided values.\nIC.Builder.CreateSub(): Creates a subtraction instruction with the provided operands.\nConstantInt::get(): Creates an LLVM ConstantInt of the specified type and value.\nBinaryOperator::CreateAdd(): Creates a binary addition instruction.\nInstruction: Represents a single operation in LLVM IR, such as addition, subtraction, or multiplication.\nlog_optzn(): A custom logging function added to log optimization steps. In this case, it logs the message \"Khagan Karimov\" to track the applied optimization for debugging or analysis purposes.\nWhen a new instruction is returned, LLVM automatically replaces the previous one with the new instruction.\nI understand that this explanation might seem too abstract. For more details, please refer to the LLVM documentation and the complete list of APIs.\nTesting Frequency of the New Optimization Pattern To test the optimization, we need a large project to compile using the version of LLVM with the new optimization pattern we just added. LLVM itself is a great candidate for this, as it consists of approximately 10 million lines of code. We will compile LLVM using our modified version of LLVM (stay tuned for my upcoming post on “Reflections on Trusting Trust”). After compiling LLVM, we see the following output:\nprocess 62594: CS6475 optimization by Khagan Karimov process 62594: CS6475 optimization by Khagan Karimov process 62594: CS6475 optimization by Khagan Karimov process 62594: CS6475 optimization by Khagan Karimov process 62644: CS6475 optimization by Khagan Karimov process 62644: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 62623: CS6475 optimization by Khagan Karimov process 63423: CS6475 optimization by Khagan Karimov process 63430: CS6475 optimization by Khagan Karimov process 63709: CS6475 optimization by Khagan Karimov process 64353: CS6475 optimization by Khagan Karimov process 66501: CS6475 optimization by Khagan Karimov process 69388: CS6475 optimization by Khagan Karimov process 69388: CS6475 optimization by Khagan Karimov This is our custom testing. LLVM developers have their own benchmark to measure how many times an optimization fires before deciding to work on it. For our example, you can see the results here.\nWriting tests for our pattern LLVM also has its unique way of testing. To understand it better, it is better to look at a test for our pattern:\n;; ALive2 verified: https://alive2.llvm.org/ce/z/ZogiKZ define i32 @test1(i32 %A, i32 %B) { %C = sub i32 %A, %B %D = mul i32 %B, 10 %E = add i32 %C, %D ret i32 %E ; CHECK-LABEL: @test1( ; CHECK-NEXT: [[F:%.*]] = mul i32 [[B:%.*]], 9 ; CHECK-NEXT: [[G:%.*]] = add i32 [[A:%.*]], [[F:%.*]] ; CHECK-NEXT: ret i32 [[G:%.*]] ; } Initially, we write LLVM IR that performs the operation A - B + B * 10 based on our pattern. The operations in the original code are as follows:\n%C = sub i32 %A, %B:\nThis subtracts B from A, resulting in C = A - B.\n%D = mul i32 %B, 10:\nThis multiplies B by 10, resulting in D = B * 10.\n%E = add i32 %C, %D:\nThis adds the result of C and D, resulting in E = (A - B) + (B * 10).\nHowever, based on the optimization, the code should simplify to A + 9 * B. This transformation involves recognizing that: (A - B) + (B * 10) = A + (B * 9)\ndefine i32 @test1(i32 %A, i32 %B) { %F = mul i32 %B, 9 ; F = B * 9 %G = add i32 %A, %F ; G = A + (B * 9) ret i32 %G ; Return G } In this optimized version, we perform the multiplication B * 9 and then add it to A, resulting in A + 9 * B. We also provide Alive2 verification of our test in the comments.\nThis was a positive test, meaning that our optimization was successfully triggered. We also need to perform a negative test, where the optimization pattern should not fire because it may result in worse code generation. For example, if a mul operation is canonicalized to a shl (shift left), the optimization should not occur.\n;; When mul B, C where C can be shl no optimization happens ;; Alive2 verified: https://alive2.llvm.org/ce/z/w23md4 define i32 @test5(i32 %A, i32 %B) { %C = sub i32 %A, %B %D = mul i32 %B, 8 %E = add i32 %C, %D ret i32 %E ; CHECK-LABEL: @test5( ; CHECK-NOT: [[F:%.*]] = mul i32 [[B:%.*]], 7 } In fact, this suggests that there is still room to further generalize our optimization pattern, particularly for shifting instructions. However, this is beyond the scope of this blog post.\nConclusion In conclusion, although LLVM is a massive project, identifying and adding a missing optimization is a valuable way to contribute to LLVM.\nAcknowledgement This blog post is based on my lecture notes from the CS-6475 Advanced Compilers course, taught by Prof. Dr. John Regehr at the University of Utah. The work was done as part of the second assignment for that course. Although I initially intended to submit a pull request (PR), another contributor made the PR while preserving my tests and the logic of the code, making me a co-contributor. You can find more details in the LLVM issue here.\n",
  "wordCount" : "1669",
  "inLanguage": "en",
  "datePublished": "2024-12-08T00:00:00Z",
  "dateModified": "2024-12-08T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Khagan Khan Karimov"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://khagankhan.github.io/posts/llvm-pass/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Just In Time",
    "logo": {
      "@type": "ImageObject",
      "url": "https://khagankhan.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://khagankhan.github.io/" accesskey="h" title="Just In Time (Alt + H)">Just In Time</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://khagankhan.github.io/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://khagankhan.github.io/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://khagankhan.github.io/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://khagankhan.github.io/about/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://khagankhan.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://khagankhan.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Be an LLVM contributor: Writing an optimization pattern for LLVM
    </h1>
    <div class="post-meta"><span title='2024-12-08 00:00:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Khagan Khan Karimov

</div>
  </header> 
  <div class="post-content"><h2 id="llvms-optimizations-are-truly-impressive">LLVM&rsquo;s Optimizations Are Truly Impressive<a hidden class="anchor" aria-hidden="true" href="#llvms-optimizations-are-truly-impressive">#</a></h2>
<p>LLVM performs aggressive optimizations. One of my favorites is the Data Structure Elimination. For example, we want to 1) compute the sum of two integers (<code>get_sum</code> function), and 2) select one of the two characters based on a condition argument (<code>get_char</code> function):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_sum</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec1; <span style="color:#75715e">// Create the first vector vec1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec2; <span style="color:#75715e">// Create the second vector vec2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec1.push_back(a); <span style="color:#75715e">// Push the first argument to vec1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec2.push_back(b); <span style="color:#75715e">// Push the second argument to vec2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> vec1[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> vec2[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// Return the sum of them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create a similar logic for string values
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_char</span>(<span style="color:#66d9ef">char</span> a, <span style="color:#66d9ef">char</span> b, <span style="color:#66d9ef">bool</span> cond) {
</span></span><span style="display:flex;"><span>    string str1{a};
</span></span><span style="display:flex;"><span>    string str2{b};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cond <span style="color:#f92672">?</span> str1[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">:</span> str2[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">get_sum</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lea</span>     <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">rsi</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">get_char</span>(<span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">bool</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">edi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">test</span>    <span style="color:#66d9ef">edx</span>, <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmove</span>   <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">esi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p>For the <code>get_sum</code> function, the compiler takes advantage of the <code>lea</code> instruction for the calculation, and for <code>get_char</code>, it uses <code>cmove</code> which it usually does to avoid potential misprediction penalties. Despite the vector being created on the heap, LLVM is able to <a href="https://gcc.godbolt.org/z/z74cThYr9">optimize both of them away</a>, whereas GCC fails to do so for the vector but succeeds for string values. This is because small strings are stored on the stack (as explained in Raymond Chen&rsquo;s <a href="https://devblogs.microsoft.com/oldnewthing/20230803-00/?p=108532">excellent post</a>), while the vector’s data is immediately allocated on the heap (For strings with a length of 15 characters (16 - 1 for the null character), the string is stored on the stack; beyond 15 characters, it is moved to the heap.)</p>
<h2 id="missed-optimizations">Missed optimizations<a hidden class="anchor" aria-hidden="true" href="#missed-optimizations">#</a></h2>
<p>Despite the many existing optimizations, there are still several optimization patterns missing. These optimizations either do not trigger frequently enough to be incorporated into the LLVM production pipeline, or they have been genuinely overlooked. During the testing of LLVM&rsquo;s optimization techniques, I came across one such missing pattern, which I discussed in <a href="https://khagan.net/posts/missed-opt/">my previous post</a>. The pattern in question is: <code>X - Y + Y * 2 = X + Y</code>. In this post, we will be adding this pattern to LLVM.</p>
<h2 id="write-an-optimization-pattern">Write an optimization pattern<a hidden class="anchor" aria-hidden="true" href="#write-an-optimization-pattern">#</a></h2>
<p>First, we need to install LLVM. After cloning the repository, I typically use the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span>cmake .. -GNinja -DLLVM_ENABLE_RTTI<span style="color:#f92672">=</span>ON -DLLVM_ENABLE_EH<span style="color:#f92672">=</span>ON -DBUILD_SHARED_LIBS<span style="color:#f92672">=</span>ON -DCMAKE_BUILD_TYPE<span style="color:#f92672">=</span>Release -DLLVM_ENABLE_ASSERTIONS<span style="color:#f92672">=</span>ON -DLLVM_ENABLE_PROJECTS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;llvm;clang&#34;</span> /path/to/llvm -DBUILTINS_CMAKE_ARGS<span style="color:#f92672">=</span>-DCOMPILER_RT_ENABLE_IOS<span style="color:#f92672">=</span>OFF
</span></span></code></pre></div><p>Next, we need to find the appropriate place to add the pattern. For this optimization, the ideal location appears to be <code>llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp</code>. Before proceeding, we want to ensure that our optimization fires as frequently as possible. To achieve this, we generalize the pattern <code>X - Y + Y * 2 = X + Y</code> to <code>X - Y + Y * N = X + Y * (N - 1)</code>.</p>
<p>LLVM provides APIs for implementing optimization patterns. These APIs are so well-developed that they can almost be considered a DSL for adding such patterns.</p>
<p>Since adding a missing optimization was part of a course assignment (see the Acknowledgement section), I will use the same technique to add and test this optimization. To begin, we add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// I keep the name of the function used for the assignment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Instruction<span style="color:#f92672">*</span> <span style="color:#a6e22e">cs6475_optimizer</span>(Instruction <span style="color:#f92672">*</span>I, InstCombinerImpl <span style="color:#f92672">&amp;</span>IC) { 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create a constant integer and placeholder values for variables and subexpressions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ConstantInt <span style="color:#f92672">*</span>C <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>; <span style="color:#75715e">// Represents a compile-time constant integer value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Value <span style="color:#f92672">*</span>X <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;       <span style="color:#75715e">// Represents a generic LLVM value (could be an instruction, constant, etc.).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Value <span style="color:#f92672">*</span>Y <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;       <span style="color:#75715e">// Another generic LLVM value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Value <span style="color:#f92672">*</span>LHS <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;     <span style="color:#75715e">// Left-hand side of an addition operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Value <span style="color:#f92672">*</span>RHS <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;     <span style="color:#75715e">// Right-hand side of an addition operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Match a pattern to see if I is an addition of two values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (match(I, m_c_Add(m_Value(LHS), m_Value(RHS)))) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if the left-hand side (LHS) matches the pattern: X - Y.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (match(LHS, m_Sub(m_Value(X), m_Value(Y))) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if the right-hand side (RHS) matches the pattern: Y * C (Y multiplied by a constant integer C).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        match(RHS, m_c_Mul(m_Value(Y), m_ConstantInt(C)))) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Create a new multiplication instruction: Y * (C - 1).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            log_optzn(<span style="color:#e6db74">&#34;Khagan Karimov&#34;</span>); <span style="color:#75715e">// Log the frequency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Value <span style="color:#f92672">*</span>NewMul <span style="color:#f92672">=</span> IC.Builder.CreateMul(
</span></span><span style="display:flex;"><span>                Y, IC.Builder.CreateSub(C, ConstantInt<span style="color:#f92672">::</span>get(C<span style="color:#f92672">-&gt;</span>getType(), <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Create a new addition instruction: X + (Y * (C - 1)).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Instruction <span style="color:#f92672">*</span>NewAdd <span style="color:#f92672">=</span> BinaryOperator<span style="color:#f92672">::</span>CreateAdd(X, NewMul);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Return the newly created instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> NewAdd;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><strong><code>ConstantInt</code></strong>: Represents an immutable integer constant at compile-time.</p>
</li>
<li>
<p><strong><code>Value</code></strong>: Base class for all values in LLVM IR, including constants, instructions, and function arguments.</p>
</li>
<li>
<p><strong><code>match()</code></strong>: Matches an LLVM IR pattern against a value or instruction.</p>
<ul>
<li><strong><code>m_c_Add</code></strong>: Matches a commutative addition operation.</li>
<li><strong><code>m_Sub</code></strong>: Matches a subtraction operation.</li>
<li><strong><code>m_c_Mul</code></strong>: Matches a commutative multiplication operation.</li>
<li><strong><code>m_Value</code></strong>: Matches any LLVM <code>Value</code>.</li>
<li><strong><code>m_ConstantInt</code></strong>: Matches an LLVM <code>ConstantInt</code>.</li>
</ul>
</li>
<li>
<p><strong><code>IC.Builder.CreateMul()</code></strong>: Creates a multiplication instruction in the current IR context using the provided values.</p>
</li>
<li>
<p><strong><code>IC.Builder.CreateSub()</code></strong>: Creates a subtraction instruction with the provided operands.</p>
</li>
<li>
<p><strong><code>ConstantInt::get()</code></strong>: Creates an LLVM <code>ConstantInt</code> of the specified type and value.</p>
</li>
<li>
<p><strong><code>BinaryOperator::CreateAdd()</code></strong>: Creates a binary addition instruction.</p>
</li>
<li>
<p><strong><code>Instruction</code></strong>: Represents a single operation in LLVM IR, such as addition, subtraction, or multiplication.</p>
</li>
<li>
<p><strong><code>log_optzn()</code></strong>: A custom logging function added to log optimization steps. In this case, it logs the message <code>&quot;Khagan Karimov&quot;</code> to track the applied optimization for debugging or analysis purposes.</p>
</li>
</ul>
<p>When a new instruction is returned, LLVM automatically replaces the previous one with the new instruction.</p>
<p>I understand that this explanation might seem too abstract. For more details, please refer to the <a href="https://llvm.org/doxygen/">LLVM documentation and the complete list of APIs</a>.</p>
<h2 id="testing-frequency-of-the-new-optimization-pattern">Testing Frequency of the New Optimization Pattern<a hidden class="anchor" aria-hidden="true" href="#testing-frequency-of-the-new-optimization-pattern">#</a></h2>
<p>To test the optimization, we need a large project to compile using the version of LLVM with the new optimization pattern we just added. LLVM itself is a great candidate for this, as it consists of approximately 10 million lines of code. We will compile LLVM using our modified version of LLVM (stay tuned for my upcoming post on &ldquo;Reflections on Trusting Trust&rdquo;). After compiling LLVM, we see the following output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>process 62594: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62594: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62594: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62594: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62644: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62644: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 62623: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 63423: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 63430: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 63709: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 64353: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 66501: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 69388: CS6475 optimization by Khagan Karimov
</span></span><span style="display:flex;"><span>process 69388: CS6475 optimization by Khagan Karimov
</span></span></code></pre></div><p>This is our custom testing. LLVM developers have their own benchmark to measure how many times an optimization fires before deciding to work on it. For our example, you can see the results <a href="https://github.com/dtcxzyw/llvm-opt-benchmark/issues/1299">here</a>.</p>
<h2 id="writing-tests-for-our-pattern">Writing tests for our pattern<a hidden class="anchor" aria-hidden="true" href="#writing-tests-for-our-pattern">#</a></h2>
<p>LLVM also has its unique way of testing. To understand it better, it is better to look at a test for our pattern:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span><span style="color:#75715e">;; ALive2 verified: https://alive2.llvm.org/ce/z/ZogiKZ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">define</span> <span style="color:#66d9ef">i32</span> @test1(<span style="color:#66d9ef">i32</span> %A, <span style="color:#66d9ef">i32</span> %B) {
</span></span><span style="display:flex;"><span>  %C = <span style="color:#66d9ef">sub</span> <span style="color:#66d9ef">i32</span> %A, %B     
</span></span><span style="display:flex;"><span>  %D = <span style="color:#66d9ef">mul</span> <span style="color:#66d9ef">i32</span> %B, <span style="color:#ae81ff">10</span>        
</span></span><span style="display:flex;"><span>  %E = <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">i32</span> %C, %D       
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">ret</span> <span style="color:#66d9ef">i32</span> %E                 
</span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-LABEL: @test1(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-NEXT:    [[F:%.*]] = mul i32 [[B:%.*]], 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-NEXT:    [[G:%.*]] = add i32 [[A:%.*]], [[F:%.*]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-NEXT:    ret i32 [[G:%.*]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Initially, we write LLVM IR that performs the operation <code>A - B + B * 10</code> based on our pattern. The operations in the original code are as follows:</p>
<ol>
<li>
<p><strong><code>%C = sub i32 %A, %B</code></strong>:<br>
This subtracts <code>B</code> from <code>A</code>, resulting in <code>C = A - B</code>.</p>
</li>
<li>
<p><strong><code>%D = mul i32 %B, 10</code></strong>:<br>
This multiplies <code>B</code> by 10, resulting in <code>D = B * 10</code>.</p>
</li>
<li>
<p><strong><code>%E = add i32 %C, %D</code></strong>:<br>
This adds the result of <code>C</code> and <code>D</code>, resulting in <code>E = (A - B) + (B * 10)</code>.</p>
</li>
</ol>
<p>However, based on the optimization, the code should simplify to <code>A + 9 * B</code>. This transformation involves recognizing that: <code>(A - B) + (B * 10) = A + (B * 9)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span><span style="color:#66d9ef">define</span> <span style="color:#66d9ef">i32</span> @test1(<span style="color:#66d9ef">i32</span> %A, <span style="color:#66d9ef">i32</span> %B) {
</span></span><span style="display:flex;"><span>  %F = <span style="color:#66d9ef">mul</span> <span style="color:#66d9ef">i32</span> %B, <span style="color:#ae81ff">9</span>       <span style="color:#75715e">; F = B * 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  %G = <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">i32</span> %A, %F      <span style="color:#75715e">; G = A + (B * 9)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">ret</span> <span style="color:#66d9ef">i32</span> %G               <span style="color:#75715e">; Return G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In this optimized version, we perform the multiplication <code>B * 9</code> and then add it to <code>A</code>, resulting in <code>A + 9 * B</code>. We also provide <code>Alive2</code> verification of our test in the comments.</p>
<p>This was a positive test, meaning that our optimization was successfully triggered. We also need to perform a negative test, where the optimization pattern should not fire because it may result in worse code generation. For example, if a <code>mul</code> operation is canonicalized to a <code>shl</code> (shift left), the optimization should not occur.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span><span style="color:#75715e">;; When mul B, C where C can be shl no optimization happens
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">;; Alive2 verified: https://alive2.llvm.org/ce/z/w23md4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">define</span> <span style="color:#66d9ef">i32</span> @test5(<span style="color:#66d9ef">i32</span> %A, <span style="color:#66d9ef">i32</span> %B) {
</span></span><span style="display:flex;"><span>  %C = <span style="color:#66d9ef">sub</span> <span style="color:#66d9ef">i32</span> %A, %B     
</span></span><span style="display:flex;"><span>  %D = <span style="color:#66d9ef">mul</span> <span style="color:#66d9ef">i32</span> %B, <span style="color:#ae81ff">8</span>      
</span></span><span style="display:flex;"><span>  %E = <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">i32</span> %C, %D       
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">ret</span> <span style="color:#66d9ef">i32</span> %E                 
</span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-LABEL: @test5(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; CHECK-NOT:    [[F:%.*]] = mul i32 [[B:%.*]], 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In fact, this suggests that there is still room to further generalize our optimization pattern, particularly for shifting instructions. However, this is beyond the scope of this blog post.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>In conclusion, although LLVM is a massive project, identifying and adding a missing optimization is a valuable way to contribute to LLVM.</p>
<h2 id="acknowledgement">Acknowledgement<a hidden class="anchor" aria-hidden="true" href="#acknowledgement">#</a></h2>
<p>This blog post is based on my lecture notes from the CS-6475 Advanced Compilers course, taught by Prof. Dr. John Regehr at the University of Utah. The work was done as part of the second assignment for that course. Although I initially intended to submit a pull request (PR), another contributor made the PR while preserving my tests and the logic of the code, making me a co-contributor. You can find more details in the LLVM issue <a href="https://github.com/llvm/llvm-project/issues/108451">here</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://khagankhan.github.io/tags/llvm/">Llvm</a></li>
      <li><a href="https://khagankhan.github.io/tags/optimization/">Optimization</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on x"
            href="https://x.com/intent/tweet/?text=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM&amp;url=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f&amp;hashtags=llvm%2coptimization">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f&amp;title=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM&amp;summary=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM&amp;source=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f&title=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on whatsapp"
            href="https://api.whatsapp.com/send?text=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM%20-%20https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on telegram"
            href="https://telegram.me/share/url?text=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM&amp;url=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Be an LLVM contributor: Writing an optimization pattern for LLVM on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Be%20an%20LLVM%20contributor%3a%20Writing%20an%20optimization%20pattern%20for%20LLVM&u=https%3a%2f%2fkhagankhan.github.io%2fposts%2fllvm-pass%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://khagankhan.github.io/">Just In Time</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
